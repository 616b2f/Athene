/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const INVENTORY_API_BASE_URL = new InjectionToken<string>('INVENTORY_API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class InventoryApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(INVENTORY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    authorsAll(): Observable<AuthorDto[]> {
        let url_ = this.baseUrl + "/api/librarian/authors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorsAll(<any>response_);
                } catch (e) {
                    return <Observable<AuthorDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthorDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAuthorsAll(response: HttpResponseBase): Observable<AuthorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuthorDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthorDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authors(body?: CreateAuthorDto | undefined): Observable<CreateAuthorDto> {
        let url_ = this.baseUrl + "/api/librarian/authors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthors(<any>response_);
                } catch (e) {
                    return <Observable<CreateAuthorDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateAuthorDto>><any>_observableThrow(response_);
        }));
    }

    protected processAuthors(response: HttpResponseBase): Observable<CreateAuthorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateAuthorDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateAuthorDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    books(body?: CreateBookDto | undefined): Observable<CreateBookDto> {
        let url_ = this.baseUrl + "/api/librarian/books";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBooks(<any>response_);
                } catch (e) {
                    return <Observable<CreateBookDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateBookDto>><any>_observableThrow(response_);
        }));
    }

    protected processBooks(response: HttpResponseBase): Observable<CreateBookDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateBookDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateBookDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    books2(body?: EditBookDto | undefined): Observable<BookDto> {
        let url_ = this.baseUrl + "/api/librarian/books";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBooks2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBooks2(<any>response_);
                } catch (e) {
                    return <Observable<BookDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookDto>><any>_observableThrow(response_);
        }));
    }

    protected processBooks2(response: HttpResponseBase): Observable<BookDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BookDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookDto>(<any>null);
    }

    /**
     * @return Success
     */
    categories(): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/librarian/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CategoryDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categories2(body?: CreateCategoryDto | undefined): Observable<CreateCategoryDto> {
        let url_ = this.baseUrl + "/api/librarian/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories2(<any>response_);
                } catch (e) {
                    return <Observable<CreateCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCategories2(response: HttpResponseBase): Observable<CreateCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateCategoryDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCategoryDto>(<any>null);
    }

    /**
     * @param q (optional) 
     * @return Success
     */
    inventoryAll(q?: string | null | undefined): Observable<Book[]> {
        let url_ = this.baseUrl + "/api/librarian/inventory?";
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInventoryAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInventoryAll(<any>response_);
                } catch (e) {
                    return <Observable<Book[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Book[]>><any>_observableThrow(response_);
        }));
    }

    protected processInventoryAll(response: HttpResponseBase): Observable<Book[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Book.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Book[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    inventory(body?: CreateInventoryItemDto | undefined): Observable<InventoryItem> {
        let url_ = this.baseUrl + "/api/librarian/inventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInventory(<any>response_);
                } catch (e) {
                    return <Observable<InventoryItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryItem>><any>_observableThrow(response_);
        }));
    }

    protected processInventory(response: HttpResponseBase): Observable<InventoryItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InventoryItem.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryItem>(<any>null);
    }

    /**
     * @return Success
     */
    inventory2(id: number): Observable<InventoryItemDetailsDto[]> {
        let url_ = this.baseUrl + "/api/librarian/inventory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInventory2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInventory2(<any>response_);
                } catch (e) {
                    return <Observable<InventoryItemDetailsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryItemDetailsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processInventory2(response: HttpResponseBase): Observable<InventoryItemDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryItemDetailsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryItemDetailsDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    configuration(clientId: string | null): Observable<void> {
        let url_ = this.baseUrl + "/_configuration/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfiguration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    publishersAll(): Observable<PublisherDto[]> {
        let url_ = this.baseUrl + "/api/librarian/publishers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishersAll(<any>response_);
                } catch (e) {
                    return <Observable<PublisherDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublisherDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPublishersAll(response: HttpResponseBase): Observable<PublisherDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PublisherDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublisherDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishers(body?: CreatePublisherDto | undefined): Observable<PublisherDto> {
        let url_ = this.baseUrl + "/api/librarian/publishers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishers(<any>response_);
                } catch (e) {
                    return <Observable<PublisherDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublisherDto>><any>_observableThrow(response_);
        }));
    }

    protected processPublishers(response: HttpResponseBase): Observable<PublisherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PublisherDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublisherDto>(<any>null);
    }

    /**
     * @return Success
     */
    publishers2(id: number): Observable<PublisherDto> {
        let url_ = this.baseUrl + "/api/librarian/publishers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishers2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishers2(<any>response_);
                } catch (e) {
                    return <Observable<PublisherDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublisherDto>><any>_observableThrow(response_);
        }));
    }

    protected processPublishers2(response: HttpResponseBase): Observable<PublisherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PublisherDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublisherDto>(<any>null);
    }

    /**
     * @return Success
     */
    rent(userId: string | null): Observable<RentedDto> {
        let url_ = this.baseUrl + "/api/librarian/rent/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRent(<any>response_);
                } catch (e) {
                    return <Observable<RentedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RentedDto>><any>_observableThrow(response_);
        }));
    }

    protected processRent(response: HttpResponseBase): Observable<RentedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RentedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RentedDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rentAll(userId: string | null, body?: number[] | null | undefined): Observable<InventoryItem[]> {
        let url_ = this.baseUrl + "/api/librarian/rent/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRentAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRentAll(<any>response_);
                } catch (e) {
                    return <Observable<InventoryItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processRentAll(response: HttpResponseBase): Observable<InventoryItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(InventoryItem.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryItem[]>(<any>null);
    }

    /**
     * @return Success
     */
    barcode(barcode: string | null): Observable<InventoryItem> {
        let url_ = this.baseUrl + "/api/librarian/rent/barcode/{barcode}";
        if (barcode === undefined || barcode === null)
            throw new Error("The parameter 'barcode' must be defined.");
        url_ = url_.replace("{barcode}", encodeURIComponent("" + barcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBarcode(<any>response_);
                } catch (e) {
                    return <Observable<InventoryItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryItem>><any>_observableThrow(response_);
        }));
    }

    protected processBarcode(response: HttpResponseBase): Observable<InventoryItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryItem>(<any>null);
    }

    /**
     * @param q (optional) 
     * @return Success
     */
    usersAll(q?: string | null | undefined): Observable<User[]> {
        let url_ = this.baseUrl + "/api/librarian/users?";
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersAll(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processUsersAll(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    users(body?: CreateUserDto | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/librarian/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processUsers(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    users2(id: string | null): Observable<User[]> {
        let url_ = this.baseUrl + "/api/librarian/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsers2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers2(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processUsers2(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }
}

export class AuthorDto implements IAuthorDto {
    id?: number;
    fullName?: string | undefined;
    info?: string | undefined;

    constructor(data?: IAuthorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.info = _data["info"];
        }
    }

    static fromJS(data: any): AuthorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["info"] = this.info;
        return data; 
    }
}

export interface IAuthorDto {
    id?: number;
    fullName?: string | undefined;
    info?: string | undefined;
}

export class CreateAuthorDto implements ICreateAuthorDto {
    fullName?: string | undefined;
    info?: string | undefined;

    constructor(data?: ICreateAuthorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.info = _data["info"];
        }
    }

    static fromJS(data: any): CreateAuthorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAuthorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["info"] = this.info;
        return data; 
    }
}

export interface ICreateAuthorDto {
    fullName?: string | undefined;
    info?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ProblemDetails";
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "ValidationProblemDetails") {
            let result = new ValidationProblemDetails();
            result.init(data);
            return result;
        }
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator; 
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    readonly errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
        this._discriminator = "ValidationProblemDetails";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this).errors![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["errors"][key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class PublisherDto implements IPublisherDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IPublisherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PublisherDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublisherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPublisherDto {
    id?: number;
    name?: string | undefined;
}

export class CategoryDto implements ICategoryDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategoryDto {
    id?: number;
    name?: string | undefined;
}

export class Language implements ILanguage {
    id?: number;
    name?: string | undefined;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ILanguage {
    id?: number;
    name?: string | undefined;
}

export class CreateBookDto implements ICreateBookDto {
    title!: string;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    authors?: AuthorDto[] | undefined;
    publisherId!: number;
    publisher?: PublisherDto;
    publishedAt?: Date | undefined;
    languageId!: number;
    authorsIds!: number[];
    categoriesIds!: number[];
    categories?: CategoryDto[] | undefined;
    language?: Language;

    constructor(data?: ICreateBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.authorsIds = [];
            this.categoriesIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.description = _data["description"];
            this.internationalStandardBookNumber = _data["internationalStandardBookNumber"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(AuthorDto.fromJS(item));
            }
            this.publisherId = _data["publisherId"];
            this.publisher = _data["publisher"] ? PublisherDto.fromJS(_data["publisher"]) : <any>undefined;
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            this.languageId = _data["languageId"];
            if (Array.isArray(_data["authorsIds"])) {
                this.authorsIds = [] as any;
                for (let item of _data["authorsIds"])
                    this.authorsIds!.push(item);
            }
            if (Array.isArray(_data["categoriesIds"])) {
                this.categoriesIds = [] as any;
                for (let item of _data["categoriesIds"])
                    this.categoriesIds!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryDto.fromJS(item));
            }
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["description"] = this.description;
        data["internationalStandardBookNumber"] = this.internationalStandardBookNumber;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        data["publisherId"] = this.publisherId;
        data["publisher"] = this.publisher ? this.publisher.toJSON() : <any>undefined;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        data["languageId"] = this.languageId;
        if (Array.isArray(this.authorsIds)) {
            data["authorsIds"] = [];
            for (let item of this.authorsIds)
                data["authorsIds"].push(item);
        }
        if (Array.isArray(this.categoriesIds)) {
            data["categoriesIds"] = [];
            for (let item of this.categoriesIds)
                data["categoriesIds"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateBookDto {
    title: string;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    authors?: AuthorDto[] | undefined;
    publisherId: number;
    publisher?: PublisherDto;
    publishedAt?: Date | undefined;
    languageId: number;
    authorsIds: number[];
    categoriesIds: number[];
    categories?: CategoryDto[] | undefined;
    language?: Language;
}

export class EditBookDto implements IEditBookDto {
    id!: number;
    title!: string;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    authors?: AuthorDto[] | undefined;
    publisherId!: number;
    publisher?: PublisherDto;
    publishedAt?: Date | undefined;
    languageId!: number;
    authorsIds!: number[];
    categoriesIds!: number[];
    categories?: CategoryDto[] | undefined;
    language?: string | undefined;

    constructor(data?: IEditBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.authorsIds = [];
            this.categoriesIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.description = _data["description"];
            this.internationalStandardBookNumber = _data["internationalStandardBookNumber"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(AuthorDto.fromJS(item));
            }
            this.publisherId = _data["publisherId"];
            this.publisher = _data["publisher"] ? PublisherDto.fromJS(_data["publisher"]) : <any>undefined;
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            this.languageId = _data["languageId"];
            if (Array.isArray(_data["authorsIds"])) {
                this.authorsIds = [] as any;
                for (let item of _data["authorsIds"])
                    this.authorsIds!.push(item);
            }
            if (Array.isArray(_data["categoriesIds"])) {
                this.categoriesIds = [] as any;
                for (let item of _data["categoriesIds"])
                    this.categoriesIds!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryDto.fromJS(item));
            }
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): EditBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["description"] = this.description;
        data["internationalStandardBookNumber"] = this.internationalStandardBookNumber;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        data["publisherId"] = this.publisherId;
        data["publisher"] = this.publisher ? this.publisher.toJSON() : <any>undefined;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        data["languageId"] = this.languageId;
        if (Array.isArray(this.authorsIds)) {
            data["authorsIds"] = [];
            for (let item of this.authorsIds)
                data["authorsIds"].push(item);
        }
        if (Array.isArray(this.categoriesIds)) {
            data["categoriesIds"] = [];
            for (let item of this.categoriesIds)
                data["categoriesIds"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["language"] = this.language;
        return data; 
    }
}

export interface IEditBookDto {
    id: number;
    title: string;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    authors?: AuthorDto[] | undefined;
    publisherId: number;
    publisher?: PublisherDto;
    publishedAt?: Date | undefined;
    languageId: number;
    authorsIds: number[];
    categoriesIds: number[];
    categories?: CategoryDto[] | undefined;
    language?: string | undefined;
}

export class BookDto implements IBookDto {
    id?: number;
    title!: string;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    publisherId!: number;
    publisherName?: string | undefined;
    publishedAt?: Date | undefined;
    authorIds?: number[] | undefined;
    categories?: string[] | undefined;
    languageId!: number;

    constructor(data?: IBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.description = _data["description"];
            this.internationalStandardBookNumber = _data["internationalStandardBookNumber"];
            this.publisherId = _data["publisherId"];
            this.publisherName = _data["publisherName"];
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["authorIds"])) {
                this.authorIds = [] as any;
                for (let item of _data["authorIds"])
                    this.authorIds!.push(item);
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            this.languageId = _data["languageId"];
        }
    }

    static fromJS(data: any): BookDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["description"] = this.description;
        data["internationalStandardBookNumber"] = this.internationalStandardBookNumber;
        data["publisherId"] = this.publisherId;
        data["publisherName"] = this.publisherName;
        data["publishedAt"] = this.publishedAt ? formatDate(this.publishedAt) : <any>undefined;
        if (Array.isArray(this.authorIds)) {
            data["authorIds"] = [];
            for (let item of this.authorIds)
                data["authorIds"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["languageId"] = this.languageId;
        return data; 
    }
}

export interface IBookDto {
    id?: number;
    title: string;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    publisherId: number;
    publisherName?: string | undefined;
    publishedAt?: Date | undefined;
    authorIds?: number[] | undefined;
    categories?: string[] | undefined;
    languageId: number;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name?: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateCategoryDto {
    name?: string | undefined;
}

export class Publisher implements IPublisher {
    id?: number;
    name?: string | undefined;

    constructor(data?: IPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Publisher {
        data = typeof data === 'object' ? data : {};
        let result = new Publisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPublisher {
    id?: number;
    name?: string | undefined;
}

export class Author implements IAuthor {
    id?: number;
    fullName?: string | undefined;
    info?: string | undefined;

    constructor(data?: IAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.info = _data["info"];
        }
    }

    static fromJS(data: any): Author {
        data = typeof data === 'object' ? data : {};
        let result = new Author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["info"] = this.info;
        return data; 
    }
}

export interface IAuthor {
    id?: number;
    fullName?: string | undefined;
    info?: string | undefined;
}

export class Category implements ICategory {
    id?: number;
    name?: string | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategory {
    id?: number;
    name?: string | undefined;
}

export class Matchcode implements IMatchcode {
    id?: number;
    value?: string | undefined;

    constructor(data?: IMatchcode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Matchcode {
        data = typeof data === 'object' ? data : {};
        let result = new Matchcode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }
}

export interface IMatchcode {
    id?: number;
    value?: string | undefined;
}

export class Article implements IArticle {
    articleId?: number;
    readonly name?: string | undefined;
    imageUrl?: string | undefined;
    readonly matchcodes?: Matchcode[] | undefined;
    inventoryItems?: InventoryItem[] | undefined;

    protected _discriminator: string;

    constructor(data?: IArticle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Article";
    }

    init(_data?: any) {
        if (_data) {
            this.articleId = _data["articleId"];
            (<any>this).name = _data["name"];
            this.imageUrl = _data["imageUrl"];
            if (Array.isArray(_data["matchcodes"])) {
                (<any>this).matchcodes = [] as any;
                for (let item of _data["matchcodes"])
                    (<any>this).matchcodes!.push(Matchcode.fromJS(item));
            }
            if (Array.isArray(_data["inventoryItems"])) {
                this.inventoryItems = [] as any;
                for (let item of _data["inventoryItems"])
                    this.inventoryItems!.push(InventoryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Article {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "Book") {
            let result = new Book();
            result.init(data);
            return result;
        }
        if (data["$type"] === "EBook") {
            let result = new EBook();
            result.init(data);
            return result;
        }
        let result = new Article();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator; 
        data["articleId"] = this.articleId;
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        if (Array.isArray(this.matchcodes)) {
            data["matchcodes"] = [];
            for (let item of this.matchcodes)
                data["matchcodes"].push(item.toJSON());
        }
        if (Array.isArray(this.inventoryItems)) {
            data["inventoryItems"] = [];
            for (let item of this.inventoryItems)
                data["inventoryItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IArticle {
    articleId?: number;
    name?: string | undefined;
    imageUrl?: string | undefined;
    matchcodes?: Matchcode[] | undefined;
    inventoryItems?: InventoryItem[] | undefined;
}

export class EBook extends Article implements IEBook {
    readonly authors?: Author[] | undefined;
    readonly categories?: Category[] | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;

    constructor(data?: IEBook) {
        super(data);
        this._discriminator = "EBook";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["authors"])) {
                (<any>this).authors = [] as any;
                for (let item of _data["authors"])
                    (<any>this).authors!.push(Author.fromJS(item));
            }
            if (Array.isArray(_data["categories"])) {
                (<any>this).categories = [] as any;
                for (let item of _data["categories"])
                    (<any>this).categories!.push(Category.fromJS(item));
            }
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
        }
    }

    static fromJS(data: any): EBook {
        data = typeof data === 'object' ? data : {};
        let result = new EBook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        super.toJSON(data);
        return data; 
    }
}

export interface IEBook extends IArticle {
    authors?: Author[] | undefined;
    categories?: Category[] | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
}

export class StockLocation implements IStockLocation {
    id?: number;
    hall?: string | undefined;
    corridor?: string | undefined;
    rack?: string | undefined;
    level?: string | undefined;
    position?: string | undefined;
    readonly oneLiner?: string | undefined;
    inventoryItems?: InventoryItem[] | undefined;

    constructor(data?: IStockLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hall = _data["hall"];
            this.corridor = _data["corridor"];
            this.rack = _data["rack"];
            this.level = _data["level"];
            this.position = _data["position"];
            (<any>this).oneLiner = _data["oneLiner"];
            if (Array.isArray(_data["inventoryItems"])) {
                this.inventoryItems = [] as any;
                for (let item of _data["inventoryItems"])
                    this.inventoryItems!.push(InventoryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StockLocation {
        data = typeof data === 'object' ? data : {};
        let result = new StockLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hall"] = this.hall;
        data["corridor"] = this.corridor;
        data["rack"] = this.rack;
        data["level"] = this.level;
        data["position"] = this.position;
        data["oneLiner"] = this.oneLiner;
        if (Array.isArray(this.inventoryItems)) {
            data["inventoryItems"] = [];
            for (let item of this.inventoryItems)
                data["inventoryItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStockLocation {
    id?: number;
    hall?: string | undefined;
    corridor?: string | undefined;
    rack?: string | undefined;
    level?: string | undefined;
    position?: string | undefined;
    oneLiner?: string | undefined;
    inventoryItems?: InventoryItem[] | undefined;
}

export class ItemNote implements IItemNote {
    id?: number;
    text?: string | undefined;
    createdAt?: Date;
    userId?: string | undefined;

    constructor(data?: IItemNote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ItemNote {
        data = typeof data === 'object' ? data : {};
        let result = new ItemNote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IItemNote {
    id?: number;
    text?: string | undefined;
    createdAt?: Date;
    userId?: string | undefined;
}

export enum Gender {
    _0 = 0,
    _1 = 1,
}

export class Address implements IAddress {
    readonly id?: number;
    street?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.street = _data["street"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["street"] = this.street;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["country"] = this.country;
        return data; 
    }
}

export interface IAddress {
    id?: number;
    street?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
}

export class BoardOfEducation implements IBoardOfEducation {
    id?: number;
    name?: string | undefined;

    constructor(data?: IBoardOfEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BoardOfEducation {
        data = typeof data === 'object' ? data : {};
        let result = new BoardOfEducation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBoardOfEducation {
    id?: number;
    name?: string | undefined;
}

export class School implements ISchool {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    address?: Address;
    boardOfEducationId?: number;
    boardOfEducation?: BoardOfEducation;
    inventoryItems?: InventoryItem[] | undefined;
    schoolClasses?: SchoolClass[] | undefined;

    constructor(data?: ISchool) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.boardOfEducationId = _data["boardOfEducationId"];
            this.boardOfEducation = _data["boardOfEducation"] ? BoardOfEducation.fromJS(_data["boardOfEducation"]) : <any>undefined;
            if (Array.isArray(_data["inventoryItems"])) {
                this.inventoryItems = [] as any;
                for (let item of _data["inventoryItems"])
                    this.inventoryItems!.push(InventoryItem.fromJS(item));
            }
            if (Array.isArray(_data["schoolClasses"])) {
                this.schoolClasses = [] as any;
                for (let item of _data["schoolClasses"])
                    this.schoolClasses!.push(SchoolClass.fromJS(item));
            }
        }
    }

    static fromJS(data: any): School {
        data = typeof data === 'object' ? data : {};
        let result = new School();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["boardOfEducationId"] = this.boardOfEducationId;
        data["boardOfEducation"] = this.boardOfEducation ? this.boardOfEducation.toJSON() : <any>undefined;
        if (Array.isArray(this.inventoryItems)) {
            data["inventoryItems"] = [];
            for (let item of this.inventoryItems)
                data["inventoryItems"].push(item.toJSON());
        }
        if (Array.isArray(this.schoolClasses)) {
            data["schoolClasses"] = [];
            for (let item of this.schoolClasses)
                data["schoolClasses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISchool {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    address?: Address;
    boardOfEducationId?: number;
    boardOfEducation?: BoardOfEducation;
    inventoryItems?: InventoryItem[] | undefined;
    schoolClasses?: SchoolClass[] | undefined;
}

export class SchoolClass implements ISchoolClass {
    readonly id?: number;
    name?: string | undefined;
    schoolId?: number;
    school?: School;

    constructor(data?: ISchoolClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.schoolId = _data["schoolId"];
            this.school = _data["school"] ? School.fromJS(_data["school"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchoolClass {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["schoolId"] = this.schoolId;
        data["school"] = this.school ? this.school.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchoolClass {
    id?: number;
    name?: string | undefined;
    schoolId?: number;
    school?: School;
}

export class Student implements IStudent {
    studentId?: string | undefined;
    schoolClassId?: number;
    schoolClass?: SchoolClass;

    constructor(data?: IStudent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.schoolClassId = _data["schoolClassId"];
            this.schoolClass = _data["schoolClass"] ? SchoolClass.fromJS(_data["schoolClass"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Student {
        data = typeof data === 'object' ? data : {};
        let result = new Student();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["schoolClassId"] = this.schoolClassId;
        data["schoolClass"] = this.schoolClass ? this.schoolClass.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStudent {
    studentId?: string | undefined;
    schoolClassId?: number;
    schoolClass?: SchoolClass;
}

export class StringIdentityUserRole implements IStringIdentityUserRole {
    userId?: string | undefined;
    roleId?: string | undefined;

    constructor(data?: IStringIdentityUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): StringIdentityUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data; 
    }
}

export interface IStringIdentityUserRole {
    userId?: string | undefined;
    roleId?: string | undefined;
}

export class StringIdentityUserClaim implements IStringIdentityUserClaim {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IStringIdentityUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): StringIdentityUserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data; 
    }
}

export interface IStringIdentityUserClaim {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class StringIdentityUserLogin implements IStringIdentityUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IStringIdentityUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.providerDisplayName = _data["providerDisplayName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): StringIdentityUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new StringIdentityUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["providerDisplayName"] = this.providerDisplayName;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IStringIdentityUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;
}

export class User implements IUser {
    surname?: string | undefined;
    lastname?: string | undefined;
    readonly fullName?: string | undefined;
    gender?: Gender;
    address?: Address;
    birthsday?: Date;
    rentedItems?: InventoryItem[] | undefined;
    studentId?: string | undefined;
    student?: Student;
    mobilePhoneNumber?: string | undefined;
    readonly roles?: StringIdentityUserRole[] | undefined;
    readonly claims?: StringIdentityUserClaim[] | undefined;
    readonly logins?: StringIdentityUserLogin[] | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surname = _data["surname"];
            this.lastname = _data["lastname"];
            (<any>this).fullName = _data["fullName"];
            this.gender = _data["gender"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            this.birthsday = _data["birthsday"] ? new Date(_data["birthsday"].toString()) : <any>undefined;
            if (Array.isArray(_data["rentedItems"])) {
                this.rentedItems = [] as any;
                for (let item of _data["rentedItems"])
                    this.rentedItems!.push(InventoryItem.fromJS(item));
            }
            this.studentId = _data["studentId"];
            this.student = _data["student"] ? Student.fromJS(_data["student"]) : <any>undefined;
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            if (Array.isArray(_data["roles"])) {
                (<any>this).roles = [] as any;
                for (let item of _data["roles"])
                    (<any>this).roles!.push(StringIdentityUserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims!.push(StringIdentityUserClaim.fromJS(item));
            }
            if (Array.isArray(_data["logins"])) {
                (<any>this).logins = [] as any;
                for (let item of _data["logins"])
                    (<any>this).logins!.push(StringIdentityUserLogin.fromJS(item));
            }
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surname"] = this.surname;
        data["lastname"] = this.lastname;
        data["fullName"] = this.fullName;
        data["gender"] = this.gender;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["birthsday"] = this.birthsday ? formatDate(this.birthsday) : <any>undefined;
        if (Array.isArray(this.rentedItems)) {
            data["rentedItems"] = [];
            for (let item of this.rentedItems)
                data["rentedItems"].push(item.toJSON());
        }
        data["studentId"] = this.studentId;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IUser {
    surname?: string | undefined;
    lastname?: string | undefined;
    fullName?: string | undefined;
    gender?: Gender;
    address?: Address;
    birthsday?: Date;
    rentedItems?: InventoryItem[] | undefined;
    studentId?: string | undefined;
    student?: Student;
    mobilePhoneNumber?: string | undefined;
    roles?: StringIdentityUserRole[] | undefined;
    claims?: StringIdentityUserClaim[] | undefined;
    logins?: StringIdentityUserLogin[] | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export enum Condition {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class InventoryItem implements IInventoryItem {
    id?: number;
    externalId?: string | undefined;
    barcode?: string | undefined;
    article?: Book | undefined;
    stockLocation?: StockLocation;
    notes?: ItemNote[] | undefined;
    rentedByUserId?: string | undefined;
    rentedBy?: User;
    rentedAt?: Date | undefined;
    purchasedAt?: Date | undefined;
    purchasePrice?: number;
    condition?: Condition;

    constructor(data?: IInventoryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.barcode = _data["barcode"];
            this.article = _data["article"] ? Book.fromJS(_data["article"]) : <any>undefined;
            this.stockLocation = _data["stockLocation"] ? StockLocation.fromJS(_data["stockLocation"]) : <any>undefined;
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(ItemNote.fromJS(item));
            }
            this.rentedByUserId = _data["rentedByUserId"];
            this.rentedBy = _data["rentedBy"] ? User.fromJS(_data["rentedBy"]) : <any>undefined;
            this.rentedAt = _data["rentedAt"] ? new Date(_data["rentedAt"].toString()) : <any>undefined;
            this.purchasedAt = _data["purchasedAt"] ? new Date(_data["purchasedAt"].toString()) : <any>undefined;
            this.purchasePrice = _data["purchasePrice"];
            this.condition = _data["condition"];
        }
    }

    static fromJS(data: any): InventoryItem {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["barcode"] = this.barcode;
        data["article"] = this.article ? this.article.toJSON() : <any>undefined;
        data["stockLocation"] = this.stockLocation ? this.stockLocation.toJSON() : <any>undefined;
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        data["rentedByUserId"] = this.rentedByUserId;
        data["rentedBy"] = this.rentedBy ? this.rentedBy.toJSON() : <any>undefined;
        data["rentedAt"] = this.rentedAt ? this.rentedAt.toISOString() : <any>undefined;
        data["purchasedAt"] = this.purchasedAt ? this.purchasedAt.toISOString() : <any>undefined;
        data["purchasePrice"] = this.purchasePrice;
        data["condition"] = this.condition;
        return data; 
    }
}

export interface IInventoryItem {
    id?: number;
    externalId?: string | undefined;
    barcode?: string | undefined;
    article?: Book | undefined;
    stockLocation?: StockLocation;
    notes?: ItemNote[] | undefined;
    rentedByUserId?: string | undefined;
    rentedBy?: User;
    rentedAt?: Date | undefined;
    purchasedAt?: Date | undefined;
    purchasePrice?: number;
    condition?: Condition;
}

export class Book extends Article implements IBook {
    title?: string | undefined;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    publisherId?: number;
    publisher?: Publisher;
    publishedAt?: Date | undefined;
    authors?: Author[] | undefined;
    categories?: Category[] | undefined;
    languageId?: number | undefined;
    language?: Language;

    constructor(data?: IBook) {
        super(data);
        this._discriminator = "Book";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.description = _data["description"];
            this.internationalStandardBookNumber = _data["internationalStandardBookNumber"];
            this.publisherId = _data["publisherId"];
            this.publisher = _data["publisher"] ? Publisher.fromJS(_data["publisher"]) : <any>undefined;
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(Author.fromJS(item));
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(Category.fromJS(item));
            }
            this.languageId = _data["languageId"];
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Book {
        data = typeof data === 'object' ? data : {};
        let result = new Book();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["description"] = this.description;
        data["internationalStandardBookNumber"] = this.internationalStandardBookNumber;
        data["publisherId"] = this.publisherId;
        data["publisher"] = this.publisher ? this.publisher.toJSON() : <any>undefined;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["languageId"] = this.languageId;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBook extends IArticle {
    title?: string | undefined;
    subTitle?: string | undefined;
    description?: string | undefined;
    internationalStandardBookNumber?: string | undefined;
    publisherId?: number;
    publisher?: Publisher;
    publishedAt?: Date | undefined;
    authors?: Author[] | undefined;
    categories?: Category[] | undefined;
    languageId?: number | undefined;
    language?: Language;
}

export class CreateInventoryItemDto implements ICreateInventoryItemDto {
    articleId!: number;
    article?: Book | undefined;
    hall!: string;
    corridor!: string;
    rack!: string;
    level!: string;
    position!: string;
    purchasedAt!: Date;
    condition!: Condition;
    note?: string | undefined;

    constructor(data?: ICreateInventoryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.articleId = _data["articleId"];
            this.article = _data["article"] ? Book.fromJS(_data["article"]) : <any>undefined;
            this.hall = _data["hall"];
            this.corridor = _data["corridor"];
            this.rack = _data["rack"];
            this.level = _data["level"];
            this.position = _data["position"];
            this.purchasedAt = _data["purchasedAt"] ? new Date(_data["purchasedAt"].toString()) : <any>undefined;
            this.condition = _data["condition"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): CreateInventoryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articleId"] = this.articleId;
        data["article"] = this.article ? this.article.toJSON() : <any>undefined;
        data["hall"] = this.hall;
        data["corridor"] = this.corridor;
        data["rack"] = this.rack;
        data["level"] = this.level;
        data["position"] = this.position;
        data["purchasedAt"] = this.purchasedAt ? formatDate(this.purchasedAt) : <any>undefined;
        data["condition"] = this.condition;
        data["note"] = this.note;
        return data; 
    }
}

export interface ICreateInventoryItemDto {
    articleId: number;
    article?: Book | undefined;
    hall: string;
    corridor: string;
    rack: string;
    level: string;
    position: string;
    purchasedAt: Date;
    condition: Condition;
    note?: string | undefined;
}

export class InventoryItemDetailsDto implements IInventoryItemDetailsDto {
    inventoryItemId?: number;
    externalId?: string | undefined;
    barcode?: string | undefined;
    stockLocation?: string | undefined;
    rentedByUserId?: string | undefined;
    rentedByUserDisplayName?: string | undefined;
    rentedAt?: Date | undefined;
    purchasedAt?: Date | undefined;
    condition?: Condition;

    constructor(data?: IInventoryItemDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryItemId = _data["inventoryItemId"];
            this.externalId = _data["externalId"];
            this.barcode = _data["barcode"];
            this.stockLocation = _data["stockLocation"];
            this.rentedByUserId = _data["rentedByUserId"];
            this.rentedByUserDisplayName = _data["rentedByUserDisplayName"];
            this.rentedAt = _data["rentedAt"] ? new Date(_data["rentedAt"].toString()) : <any>undefined;
            this.purchasedAt = _data["purchasedAt"] ? new Date(_data["purchasedAt"].toString()) : <any>undefined;
            this.condition = _data["condition"];
        }
    }

    static fromJS(data: any): InventoryItemDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryItemId"] = this.inventoryItemId;
        data["externalId"] = this.externalId;
        data["barcode"] = this.barcode;
        data["stockLocation"] = this.stockLocation;
        data["rentedByUserId"] = this.rentedByUserId;
        data["rentedByUserDisplayName"] = this.rentedByUserDisplayName;
        data["rentedAt"] = this.rentedAt ? this.rentedAt.toISOString() : <any>undefined;
        data["purchasedAt"] = this.purchasedAt ? this.purchasedAt.toISOString() : <any>undefined;
        data["condition"] = this.condition;
        return data; 
    }
}

export interface IInventoryItemDetailsDto {
    inventoryItemId?: number;
    externalId?: string | undefined;
    barcode?: string | undefined;
    stockLocation?: string | undefined;
    rentedByUserId?: string | undefined;
    rentedByUserDisplayName?: string | undefined;
    rentedAt?: Date | undefined;
    purchasedAt?: Date | undefined;
    condition?: Condition;
}

export class CreatePublisherDto implements ICreatePublisherDto {
    name?: string | undefined;

    constructor(data?: ICreatePublisherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreatePublisherDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePublisherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreatePublisherDto {
    name?: string | undefined;
}

export class RentedDto implements IRentedDto {
    user?: User;
    rentedItems?: InventoryItem[] | undefined;

    constructor(data?: IRentedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["rentedItems"])) {
                this.rentedItems = [] as any;
                for (let item of _data["rentedItems"])
                    this.rentedItems!.push(InventoryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RentedDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.rentedItems)) {
            data["rentedItems"] = [];
            for (let item of this.rentedItems)
                data["rentedItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRentedDto {
    user?: User;
    rentedItems?: InventoryItem[] | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    surname!: string;
    lastname!: string;
    gender?: Gender;
    addressStreet?: string | undefined;
    addressZip?: string | undefined;
    addressCity?: string | undefined;
    addressCountry?: string | undefined;
    birthsday?: Date;
    studentId?: string | undefined;
    student?: Student;
    phoneNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    schoolId?: number;
    schoolClassId?: number;
    schoolClassName?: number;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surname = _data["surname"];
            this.lastname = _data["lastname"];
            this.gender = _data["gender"];
            this.addressStreet = _data["addressStreet"];
            this.addressZip = _data["addressZip"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.birthsday = _data["birthsday"] ? new Date(_data["birthsday"].toString()) : <any>undefined;
            this.studentId = _data["studentId"];
            this.student = _data["student"] ? Student.fromJS(_data["student"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.schoolId = _data["schoolId"];
            this.schoolClassId = _data["schoolClassId"];
            this.schoolClassName = _data["schoolClassName"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surname"] = this.surname;
        data["lastname"] = this.lastname;
        data["gender"] = this.gender;
        data["addressStreet"] = this.addressStreet;
        data["addressZip"] = this.addressZip;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["birthsday"] = this.birthsday ? formatDate(this.birthsday) : <any>undefined;
        data["studentId"] = this.studentId;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["schoolId"] = this.schoolId;
        data["schoolClassId"] = this.schoolClassId;
        data["schoolClassName"] = this.schoolClassName;
        return data; 
    }
}

export interface ICreateUserDto {
    surname: string;
    lastname: string;
    gender?: Gender;
    addressStreet?: string | undefined;
    addressZip?: string | undefined;
    addressCity?: string | undefined;
    addressCountry?: string | undefined;
    birthsday?: Date;
    studentId?: string | undefined;
    student?: Student;
    phoneNumber?: string | undefined;
    mobilePhoneNumber?: string | undefined;
    schoolId?: number;
    schoolClassId?: number;
    schoolClassName?: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}